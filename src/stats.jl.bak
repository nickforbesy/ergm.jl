module stats

export EdgeTriangle, stat_count, get_stats, set_state, test_update, apply_update
using ergm.spaces
using SparseArrays
using LinearAlgebra

mutable struct EdgeTriangle
    graph :: SparseGraph
    edge_count
    triangle_count
    max_edge_count
    max_triangle_count
    cached_counts
    
    function EdgeTriangle(space)
        if !(space isa SparseGraphs)
            print("EdgeTriangle statistics only supported \
                  for undirected sparse graphs.")
        end

        n = space.number_of_nodes

        new(
            empty(space),
            0,
            0,
            n * (n - 1) ÷ 2,
            n * (n - 1) * (n - 2) ÷ 6,
            Dict()
        )
    end
end

function stat_count(stats :: EdgeTriangle)
    2
end

function set_state(stats :: EdgeTriangle, G :: SparseGraph)
    stats.G = G
    A = G.adjacency
    stats.edge_count = sum(A) / 2
    stats.triangle_count = sum(A ^ 2 .* A) / 6
    stats.cached_counts = Dict()
end

function test_update(stats :: EdgeTriangle, update; counts=false)
    if update ∈ keys(stats.cached_counts)
        if counts
            return stats.cached_counts[update]
        else
            return stats.cached_counts[update] ./ [stats.max_edge_count, stats.max_triangle_count]
        end
    end
    
    (i, j), x = update
    old_x = stats.G[(i, j)]
    
    new_counts = if x == old_x
        [edge_count, triangle_count]
    else
        A = stats.G.adjacency
        new_edge_count = stats.edge_count + x - old_x
        new_triangle_count = stats.triangle_count + (x - old_x) * sum(A[i, :] .* A[:, j])
        [new_edge_count, new_triangle_count]
    end
    
    stats.cached_counts[update] = new_counts
    
    if counts
        new_counts
    else
        new_counts ./ [stats.max_edge_count, stats.max_triangle_count]
    end
end

function apply_update(stats :: EdgeTriangle, update)
    stats.edge_count, stats.triangle_count = test_update(stats, update, counts=true)
    ix, x = update
    stats.G[ix] = x
end

function get_stats(stats :: EdgeTriangle)
    [stats.edge_count, stats.triangle_count] ./ [stats.max_edge_count, stats.max_triangle_count]
end

function get_stats(stats :: EdgeTriangle, G :: SparseGraph)
    set_state(stats, G)
    get_stats(stats)
end


mutable struct EdgeLocalTriangleStats
    G :: SparseGraph

    node_positions
    local_radius

    local_G
    
    edge_count
    local_triangle_count
    
    max_edge_count
    max_local_triangle_count
    
    cached_counts
    
    function EdgeLocalTriangleStats(node_positions, local_radius)
        n = size(node_positions, 2)
        G = Graph(zeros(Bool, n, n))

        full_local_G = Graph(zeros(Bool, n, n))

        for (i, j) ∈ keys(G)
            x = node_positions[:, i]
            y = node_positions[:, j]
            d = norm(x - y)

            if d < local_radius
                full_local_G[(i, j)] = true
            end
        end

        LA = full_local_G.adjacency
        max_local_triangle_count = sum(LA ^ 2 .* LA)

        new(
            G,
            node_positions,
            local_radius,
            Graph(zeros(Bool, n, n)),
            0,
            0,
            n * (n - 1) ÷ 2,
            max_local_triangle_count,
            Dict()
        )
    end
end

function stat_count(stats :: EdgeLocalTriangleStats)
    2
end

function set_state(stats :: EdgeLocalTriangleStats, G :: SparseGraph)
    stats.G = G
    A = G.adjacency
    n = size(A, 1)
    stats.local_G = Graph(zeros(Bool, n, n))

    for (i, j) ∈ keys(G)
        if G[(i, j)]
            x = stats.node_positions[:, i]
            y = stats.node_positions[:, j]
            d = norm(x - y)

            if d < stats.local_radius
                stats.local_G[(i, j)] = true
            end
        end
    end

    LA = stats.local_G.adjacency
    stats.edge_count = sum(A) / 2
    stats.local_triangle_count = sum(LA ^ 2 .* LA) / 6
    stats.cached_counts = Dict()
end

function test_update(stats :: EdgeLocalTriangleStats, update; counts=false)
    if update ∈ keys(stats.cached_counts)
        if counts
            return stats.cached_counts[update]
        else
            return stats.cached_counts[update] ./ [stats.max_edge_count, stats.max_local_triangle_count]
        end
    end
    
    (i, j), x = update
    old_x = stats.G[(i, j)]
    
    new_counts = if x == old_x
        [stats.edge_count, stats.local_triangle_count]
    else
        new_edge_count = stats.edge_count + x - old_x
        x1 = stats.node_positions[:, i]
        x2 = stats.node_positions[:, j]
        d = norm(x1 - x2)

        new_local_triangle_count = if d < stats.local_radius
            LA = stats.local_G.adjacency
            stats.local_triangle_count + (x - old_x) * sum(LA[i, :] .* LA[:, j])
        else
            stats.local_triangle_count
        end

        [new_edge_count, new_local_triangle_count]
    end
    
    stats.cached_counts[update] = new_counts
    
    if counts
        new_counts
    else
        new_counts ./ [stats.max_edge_count, stats.max_local_triangle_count]
    end
end

function apply_update(stats :: EdgeLocalTriangleStats, update)
    stats.edge_count, stats.local_triangle_count = test_update(stats, update, counts=true)
    ix, x = update
    stats.G[ix] = x
end

function get_stats(stats :: EdgeLocalTriangleStats)
    [stats.edge_count, stats.local_triangle_count] ./ [stats.max_edge_count, stats.max_local_triangle_count]
end

function get_stats(stats :: EdgeLocalTriangleStats, G :: SparseGraph)
    set_state(stats, G)
    get_stats(stats)
end


mutable struct LocalThreeNodeMotifStats
    node_positions :: Matrix{Float64}
    local_radius :: Float64

    edge_normalization :: Int
    triangle_normalization :: Int

    graph :: SparseGraph
    local_edges :: Vector{Set{Int}}

    current_counts :: Vector{Int}
    cached_counts :: Dict{Tuple{Tuple{Int, Int}, Bool}, Vector{Int}}
    
    function LocalThreeNodeMotifStats(node_positions, local_radius) 
        n = size(node_positions, 1)
        
        # all local motif counts should be roughly linear in number
        # of nodes, and if local synapses dominant the total edge
        # count then the edge count should also be roughly linear
        # edge_normalization = n
        # motif_7_normalization = n
        edge_normalization = n * (n - 1) ÷ 2
        triangle_normalization = n * (n - 1) * (n - 2) ÷ 6

        new(
            node_positions,
            local_radius,
            edge_normalization,
            triangle_normalization,
            Graph(spzeros(Bool, n, n)),
            [Set{Int}() for _ ∈ 1:n],
            zeros(Int, 2),
            Dict{Tuple{Tuple{Int, Int}, Bool}, Vector{Int}}()
        )
    end
end

function stat_count(stats :: LocalThreeNodeMotifStats)
    2
end

function set_state(stats :: LocalThreeNodeMotifStats, state :: SparseGraph)
    A = state.adjacency
    n = size(A, 1)

    stats.graph = state
    stats.local_edges = [Set{Int}() for _ ∈ 1:n]
    
    for (i, j) ∈ zip(findnz(A)[1:2]...)
        d = norm(stats.node_positions[i, :] - stats.node_positions[j, :]) 
        if d < stats.local_radius
            push!(stats.local_edges[i], j)
        end
    end
    
    edge_count = sum(A)
    triangle_count = 0
    
    for (i, j) ∈ zip(findnz(A)[1:2]...)
        d = norm(stats.node_positions[i, :] - stats.node_positions[j, :]) 
        if d < stats.local_radius
            triangle_count += length(
                stats.local_edges[i] ∩ stats.local_edges[j]
            )
        end
    end
    
    triangle_count ÷= 6

    stats.current_counts = [edge_count, triangle_count]
    stats.cached_counts = Dict()
end

function test_update(stats :: LocalThreeNodeMotifStats, update :: Tuple{Tuple{Int, Int}, Bool}; counts=false)
    if update ∈ keys(stats.cached_counts)
        if counts
            return stats.cached_counts[update]
        else
            return stats.cached_counts[update] ./ [stats.edge_normalization, stats.triangle_normalization]
        end
    end
    
    ((i, j), x) = update
    old_x = stats.graph[(i, j)]

    δ_edge_count = x - old_x

    d = norm(stats.node_positions[i, :] - stats.node_positions[j, :]) 
    δ_triangle_count = (d < stats.local_radius) * (x - old_x) * length(
        stats.local_edges[i] ∩ stats.local_edges[j]
    )

    new_counts = stats.current_counts + [δ_edge_count, δ_triangle_count]
    stats.cached_counts[update] = new_counts
    
    if counts
        new_counts
    else
        new_counts ./ [stats.edge_normalization, stats.triangle_normalization]
    end
end

function apply_update(stats :: LocalThreeNodeMotifStats, update :: Tuple{Tuple{Int, Int}, Bool})
    stats.current_counts = test_update(stats, update, counts=true)

    ((i, j), x) = update
    d = norm(stats.node_positions[i, :] - stats.node_positions[j, :]) 

    if d < stats.local_radius
        old_x = stats.graph[(i, j)]

        if x && !old_x
            # inserting new edge
            push!(stats.local_edges[i], j)
            push!(stats.local_edges[j], i)
        elseif !x && old_x
            # removing old edge
            delete!(stats.local_edges[i], j)
            delete!(stats.local_edges[j], i)
        end
    end

    stats.graph[(i, j)] = x
    stats.cached_counts = Dict()
    nothing
end

function get_stats(stats :: LocalThreeNodeMotifStats)
    stats.current_counts ./ [stats.edge_normalization, stats.triangle_normalization]
end

function get_stats(stats :: LocalThreeNodeMotifStats, observation :: SparseGraph)
    set_state(stats, observation)
    get_stats(stats)
end

end
